---
title:   복잡한 문제
isChild: true
anchor:  complex_problem
---

## 복잡한 문제 {#complex_problem_title}

의존성 주입에 대한 글을 읽어본 적이 있다면 아마 *"제어의 역전"* 이나 *"의존 관계 역전의 원칙"* 이라는 말을 본 적이
있을 겁니다. 의존성 주입으로 풀 수 있는 복잡한 문제들이죠.

### 제어의 역전

제어의 역전(Inversion of Control)은 말 그대로, 시스템의 "제어권을 뒤집는" 것입니다. 우리가 다루는 객체들의 구성에 대한
제어를 해당 객체들과 완전히 분리시킴으로써 말이죠. 의존성 주입이라는 관점에서 보면, 우리가 다루는 객체들의 생성과 의존
관계의 설정을 시스템의 다른 곳에서 수행함으로써 객체들간의 의존성을 느슨하게 한다는 말이 됩니다.

지난 몇 년간, PHP 프레임워크들은 제어의 역전을 이루어 왔습니다. 하지만 이러한 의문이 생겨났죠. "어떤 부분의 제어권을
역전시켰고 그 제어권은 어디로 갔는가?" 예를 들어 MVC 프레임워크는 보통 수퍼 객체나 베이스 컨트롤러를 제공하는데,
우리가 구현하는 컨트롤러는 반드시 베이스 컨트롤러를 상속받아야 하고 그래야만 의존 관계에 있는 모델이나 뷰에 접근할 수
있게 됩니다. 이것은 제어의 역전이 **맞기는 한데** 의존 관계를 느슨하게 만들었다기 보다는 단순히 위치를 이동시킨 것
뿐입니다.

의존성 주입을 사용하게 되면 이런 문제를 유연하게 풀 수 있게 됩니다. 우리가 원하는 의존 관계를 우리가 필요할 때에만,
의존 관계를 전혀 하드코딩하지 않고서도, 의존성을 주입시킴으로써 말이죠.

### S.O.L.I.D.

#### 단일 책임 원칙 (SRP)

단일 책임 원칙은 액터와 고급 아키텍처에 관한 원칙입니다. "클래스는 한가지 이유로만 변경되어야 한다."라는 내용입니다.
이는 모든 클래스가 소프트웨어가 제공하는 기능의 _오직_ 한가지에 대해서만 책임을 져야 함을 의미합니다. 이 접근법의 가장
큰 이점은 코드 _재사용성_을 향상시킬 수 있다는 것입니다. 클래스를 한가지만 하도록 설계함으로써, 우리는 다른 어떤
프로그램에서도 이 클래스를 사용할 수 있습니다(또는 재사용 할 수 있습니다).

#### 개방/폐쇄(Open/Closed)의 원칙 (OCP)

개방/폐쇄 원칙은 클래스 디자인 및 기능 확장에 대한 것입니다. "소프트웨어 개체(클래스, 모듈, 함수 등)는 확장을 위해 열려
있어야 하지만 수정을 위해 닫혀 있어야 합니다.". 즉, 새로운 기능이 필요할 때는 기존 코드를 수정하기 보다 기존 코드를 활용
하는 새로운 코드를 작성하는 방식으로 모듈, 클래스 및 함수를 설계해야 합니다. 실용적 측면에서 보면, 이것은 _인터페이스_를
구현하고 준수하는 클래스를 작성한 다음 특정 클래스 대신 해당 인터페이스에 대해 타입 힌트를 작성해야 함을 의미합니다.

이 접근법의 가장 큰 이점은 기존 코드를 수정하지 않고도 새로운 무언가를 지원함으로써 코드를 매우 쉽게 확장 할 수 있다는
것입니다. 즉, QA 시간을 줄일 수 있고 응용 프로그램에 부정적인 영향을 미치는 위험이 크게 줄어 듭니다. 우리는 새로운 코드
를 빠르고, 더 확신을 갖고 배포 할 수 있습니다.

#### 리스코브(Liskov) 치환의 원칙 (LSP)

Liskov 치환 원칙은 하위 유형 지정과 상속에 관한 것입니다. "자식 클래스는 절대로 부모 클래스의 타입 정의를 깨뜨리
면 안됩니다". 로버트 C. 마틴(Robert C. Martin)의 말에 따르면, "서브 타입은 부모 타입을 대체 할 수 있어야 합니다".

예를 들어 `embed()` 메서드를 정의한 `FileInterface` 인터페이스가 있고, 각각 `embed()` 메소드를 구현한 `Audio`와 `Video`
클래스가 있다면, 우리는 `embed()` 메소드의 사용은 항상 우리가 의도한 대로 동작할 것이라고 기대할 수 있습니다. 나중에 우
리가 `FileInterface` 인터페이스를 구현하는 `PDF` 클래스나 `Gist` 클래스를 만든다면, 우리는 이미`FileInterface()` 인터페이스가 무엇을
하는지 알고 있습니다. 이 접근법의 가장 큰 장점은 유연하고 쉽게 구성 가능한 프로그램을 만들 수 있다는 것입니다. 어떤 타입
(예 : 'FileInterface')에 해당하는 하나의 객체를 다른 객체로 변경할 때 우리 프로그램 안의 다른 부분은 변경할 필요가 없기
때문입니다.

#### 인터페이스 분리의 원칙 (ISP)

인터페이스 분리 원칙은 _비즈니스 로직과 클라이언트 간_ 의 통신에 관한 것입니다.
"클라이언트는 사용하지 않는 메소드에 의존하면 안됩니다.". 즉, 모든 클래스가 따라야 하는 하나의 단일 인터페이스 대신, 클
래스가 하나 혹은 그 이상을 구현할 수 있는 더 작고 개념에 기반한 인터페이스 세트를 제공해야만 합니다.

예를 들어, `Car` 또는 `Bus` 클래스는 `steeringWheel()` 메소드에 관심이 있지만 `Motorcycle` 이나 `Tricycle` 클래스는 그렇
지 않습니다. 반대로 `Motorcycle` 또는 `Tricycle` 클래스는 `handlebars()` 메소드에 관심이 있지만 `Car` 또는 `Bus` 클래스
는 그렇지 않습니다. 이러한 유형의 모든 차량에 `steeringWheel()`과 `handlebars()`를 모두 지원할 필요가 없으므로 소스 인터
페이스를 분리해야합니다.

#### 의존성 역전의 원칙 (DIP)

The Dependency Inversion Principle is about removing hard-links between discrete classes so that new functionality can
be leveraged by passing a different class. It states that one should *"Depend on Abstractions. Do not depend on
concretions."*. Put simply, this means our dependencies should be interfaces/contracts or abstract classes rather than
concrete implementations. We can easily refactor the above example to follow this principle.

의존성 역전의 원칙은 개별 클래스 간의 하드 링크를 제거하여 다른 클래스를 전달하는 방식으로 새로운 기능을 활용할 수 있도
록하는 것입니다. *"추상화에 의존해야 하고, 구현에 의존하지 말아야 합니다."*. 간단히 말해서, 이는 우리의 의존성이 구체적
인 구현이 아닌 인터페이스/계약(contract) 또는 추상 클래스여야 함을 의미합니다. 우리는 위의 예를 이 원리에 따라 쉽게 리펙
토링 할 수 있습니다.

{% highlight php %}
<?php
namespace Database;

class Database
{
    protected $adapter;

    public function __construct(AdapterInterface $adapter)
    {
        $this->adapter = $adapter;
    }
}

interface AdapterInterface {}

class MysqlAdapter implements AdapterInterface {}
{% endhighlight %}

`Database` 클래스는 이제 구체 클래스가 아닌 인터페이스에 의존하게 되었습니다. 이렇게 하면 몇 가지 장점이 있습니다.

여러분이 팀 프로젝트를 하는 중이고, 어댑터는 팀의 동료가 만드는 중이라고 생각해봅시다. 이전의 예제 코드와 같은
상태라면 유닛 테스트를 작성하기 위해서 어댑터의 mock 객체를 만들려면, 여러분의 동료가 어댑터를 완성해주기를 기다려야
할 것입니다. 지금의 코드는 인터페이스에 의존하고 있으므로, 여러분의 동료가 해당 인터페이스의 규약을 잘 따를 것이라는
것을 알 수 있고, 우리는 해당 인터페이스를 사용해서 행복하게 mock 객체를 만들면 됩니다.

또한 인터페이스에 의존하는 코드의 큰 장점은 확장성입니다. 시간이 흘러 처음 사용하던 것과는 다른 DBMS로 마이그레이션
하려고 할 때, 해당 인터페이스를 구현하는 새로운 어댑터를 구현하여 원래의 어댑터를 사용하던 곳에 대신 넣기만 하면
됩니다. 어댑터들은 동일한 인터페이스의 규약을 따르고 있다는 것을 우리가 알고 있기 때문에 추가적인 리팩토링을 해야할
필요가 없습니다.
